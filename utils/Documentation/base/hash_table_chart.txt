class
	HASH_TABLE [G, K -> detachable HASHABLE]

General
	cluster: elks
	description: "Hash tables, used to store items identified by hashable keys"
	create: make, make_equal

Ancestors
	MISMATCH_CORRECTOR
	READABLE_INDEXABLE* [G]
	TABLE* [G, H]
	TABLE_ITERABLE* [G, K]
	UNBOUNDED* [G]

Queries
	after: BOOLEAN
	at alias "@" (key: K): detachable G
	capacity: INTEGER_32
	changeable_comparison_criterion: BOOLEAN -- (from CONTAINER)
	conflict: BOOLEAN
	count: INTEGER_32
	current_keys: ARRAY [K]
	cursor: CURSOR
	definite_item (key: K): G
	disjoint (other: HASH_TABLE [G, K]): BOOLEAN
	Extendible: BOOLEAN
	found: BOOLEAN
	found_item: detachable G
	Full: BOOLEAN
	has (key: K): BOOLEAN
	has_item (v: G): BOOLEAN
	has_key (key: K): BOOLEAN
	hash_code_of (a_key: attached K): INTEGER_32
	inserted: BOOLEAN
	is_empty: BOOLEAN -- (from FINITE)
	is_equal (other: [like Current] HASH_TABLE [G, K]): BOOLEAN
	is_inserted (v: G): BOOLEAN -- (from COLLECTION)
	item alias "[]" (key: K): detachable G
	item_for_iteration: G
	iteration_item (i: INTEGER_32): G
	iteration_lower: INTEGER_32
	iteration_upper: INTEGER_32
	key_for_iteration: K
	linear_representation: ARRAYED_LIST [G]
	Mismatch_information: MISMATCH_INFORMATION -- (from MISMATCH_CORRECTOR)
	new_cursor: HASH_TABLE_ITERATION_CURSOR [G, K]
	not_found: BOOLEAN
	object_comparison: BOOLEAN -- (from CONTAINER)
	occurrences (v: G): INTEGER_32
	off: BOOLEAN
	prunable: BOOLEAN
	removed: BOOLEAN
	replaced: BOOLEAN
	same_keys (a_search_key, a_key: K): BOOLEAN
	valid_cursor (c: CURSOR): BOOLEAN
	valid_iteration_index (i: INTEGER_32): BOOLEAN

Commands
	accommodate (n: INTEGER_32)
	compare_objects -- (from CONTAINER)
	compare_references -- (from CONTAINER)
	copy (other: [like Current] HASH_TABLE [G, K])
	extend (new: G; key: K)
	fill (other: CONTAINER [G]) -- (from COLLECTION)
	force (new: G; key: K)
	forth
	go_to (c: CURSOR)
	make (n: INTEGER_32)
	make_equal (n: INTEGER_32)
	merge (other: HASH_TABLE [G, K])
	prune (v: G)
	put (new: G; key: K)
	remove (key: K)
	replace (new: G; key: K)
	replace_key (new_key, old_key: K)
	search (key: K)
	start
	wipe_out

Constraints
	keys not void
	content not void
	keys enough capacity
	content enough capacity
	valid iteration position
	control non negative
	special status
	count big enough
	count small enough
	slot count big enough

