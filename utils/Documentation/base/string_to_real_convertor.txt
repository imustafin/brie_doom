note
	description: "String to real/double convertor"
	library: "Free implementation of ELKS library"
	status: "See notice at end of class."
	legal: "See notice at end of class."
	date: "$Date: 2017-03-23 19:18:26 +0000 (Thu, 23 Mar 2017) $"
	revision: "$Revision: 100033 $"

frozen class 
	STRING_TO_REAL_CONVERTOR

inherit
	STRING_TO_NUMERIC_CONVERTOR

create 
	make

feature {NONE} -- Initialization

	make
			-- Initialize.
		do
			create leading_separators.make_from_string (" ")
			create trailing_separators.make_from_string (" ")
		ensure
			leading_separators_set: leading_separators ~ " "
			trailing_separators_set: trailing_separators ~ " "
			leading_separators_not_acceptable: not leading_separators_acceptable
			trailing_separatorsnot_acceptable: not trailing_separators_acceptable
		end
	
feature -- Status reporting

	conversion_type_valid (type: INTEGER_32): BOOLEAN
			-- Is conversion type `type` valid?
		do
			Result := real_double_type_valid (type)
		end

	overflowed: BOOLEAN
			-- Is real number parsed so far overflowed?
		do
			Result := False
		end

	underflowed: BOOLEAN
			-- Is real number parsed so far underflowed?
		do
			Result := False
		end

	parse_successful: BOOLEAN
			-- This only means we didn't enter an invalid state when parsing,
			-- it doesn't mean that we have got an valid double/real number.
			-- You need to check `is_double` or `is_real`.
		do
			Result := last_state /= 9
		end

	separators_valid (separators: STRING_8): BOOLEAN
			-- Are separators contained in `separators` valid?
		local
			i: INTEGER_32
			c: CHARACTER_8
			l_c: INTEGER_32
			done: BOOLEAN
		do
			from
				i := 1
				l_c := separators.count
				done := False
				Result := True
			until
				i > l_c or done
			loop
				c := separators.item (i)
				if (c >= '0' and c <= '9') or c = '+' or c = '-' or c = 'E' or c = 'e' then
					done := True
					Result := False
				end
				i := i + 1
			end
		end

	is_integral_double: BOOLEAN
			-- Is character sequence that has been parsed represents a valid double?
		do
			Result := (last_state > 1 and last_state < 9) and (not needs_digit)
		end

	is_integral_real: BOOLEAN
			-- Is character sequence that has been parsed represents a valid real?	
		do
			Result := is_integral_double
		end

	is_part_of_double: BOOLEAN
			-- Is character sequence that has been parsed so far a valid start part of double?
		do
			Result := last_state /= 9
		end

	is_part_of_real: BOOLEAN
			-- Is character sequence that has been parsed so far a valid start part of real?
		do
			Result := is_part_of_double
		end

	parsed_double: REAL_64
			-- Parsed double value
		do
			if has_negative_exponent then
				exponent := - exponent
			end
			if has_fractional_part then
				natural_part := natural_part + fractional_part / fractional_divider
			end
			if is_negative then
				Result := - natural_part * (10.0 ^ exponent.to_double)
			else
				Result := natural_part * (10.0 ^ exponent.to_double)
			end
		end

	parsed_real: REAL_32
			-- Parsed real value
		do
			Result := parsed_double.truncated_to_real
		end
	
feature -- Status setting

	reset (type: INTEGER_32)
			-- Reset current convertor to parse real number string of type `type`.
		do
			conversion_type := type
			sign := 0
			last_state := 0
			natural_part := 0.to_double
			fractional_part := 0.to_double
			fractional_divider := 0.to_double
			exponent := 0
			is_negative := False
			has_negative_exponent := False
			has_fractional_part := False
			needs_digit := False
		ensure then
			natural_part_set: natural_part = 0.to_double
			fractional_part_set: fractional_part = 0.to_double
			fractional_divider_set: fractional_divider = 0.to_double
			exponent_set: exponent = 0
			is_negative_set: not is_negative
			has_negative_exponent_set: not has_negative_exponent
			has_fractional_part_set: not has_fractional_part
			needs_digit_set: not needs_digit
		end
	
feature -- Parse

	parse_string_with_type (s: READABLE_STRING_GENERAL; type: INTEGER_32)
			-- Parse string `s` as real number of type `type`.
		local
			i, nb: INTEGER_32
			l_area8: SPECIAL [CHARACTER_8]
			l_area32: SPECIAL [CHARACTER_32]
			l_c: CHARACTER_32
			l_code: NATURAL_32
		do
			reset (type)
			i := 0
			nb := s.count
			if attached {READABLE_STRING_8} s as l_str8 then
				from
					l_area8 := l_str8.area
				until
					i = nb or last_state = 9
				loop
					parse_character (l_area8.item (i))
					i := i + 1
				end
			elseif attached {READABLE_STRING_32} s as l_str32 then
				from
					l_area32 := l_str32.area
				until
					i = nb or last_state = 9
				loop
					l_c := l_area32.item (i)
					if l_c.is_character_8 then
						parse_character (l_c.to_character_8)
					else
						last_state := 9
					end
					i := i + 1
				end
			else
				from
					i := 1
					nb := s.count
				until
					i > nb or last_state = 9
				loop
					l_code := s.code (i)
					if l_code.is_valid_character_8_code then
						parse_character (l_code.to_character_8)
					else
						last_state := 9
					end
					i := i + 1
				end
			end
		end

	parse_character (c: CHARACTER_8)
			-- Parse character `c`.
		do
			inspect last_state
			when 0 then
				if c.is_digit then
					last_state := 2
					natural_part := c.code - 48.to_double
				elseif c = '+' then
					last_state := 1
				elseif c = '-' then
					last_state := 1
					is_negative := True
				elseif leading_separators_acceptable and then leading_separators.has (c) then
				elseif c = '.' then
					last_state := 3
					needs_digit := True
				else
					last_state := 9
				end
			when 1 then
				if c.is_digit then
					last_state := 2
					natural_part := c.code - 48.to_double
				elseif c = '.' then
					last_state := 3
					needs_digit := True
				else
					last_state := 9
				end
			when 2 then
				if c.is_digit then
					natural_part := natural_part * 10.0 + c.code.to_double - 48.to_double
				elseif c = '.' then
					last_state := 3
					needs_digit := False
				elseif trailing_separators_acceptable and then trailing_separators.has (c) then
					last_state := 8
				elseif c.as_lower = 'e' then
					last_state := 5
				else
					last_state := 9
				end
			when 3 then
				if c.is_digit then
					last_state := 4
					has_fractional_part := True
					fractional_part := c.code - 48.to_double
					fractional_divider := 10.0
					needs_digit := False
				elseif c.as_lower = 'e' and not needs_digit then
					needs_digit := True
					last_state := 5
				elseif trailing_separators_acceptable and then trailing_separators.has (c) then
					last_state := 8
				else
					last_state := 9
				end
			when 4 then
				if c.is_digit then
					fractional_part := fractional_part * 10.0 + (c.code - 48).to_double
					fractional_divider := fractional_divider * 10.0
				elseif c.as_lower = 'e' then
					needs_digit := True
					last_state := 5
				elseif trailing_separators_acceptable and then trailing_separators.has (c) then
					last_state := 8
				else
					last_state := 9
				end
			when 5 then
				if c = '-' then
					has_negative_exponent := True
					last_state := 6
				elseif c = '+' then
					last_state := 6
				elseif c.is_digit then
					needs_digit := False
					last_state := 7
					exponent := c.code - 48
				else
					last_state := 9
				end
			when 6 then
				if c.is_digit then
					last_state := 7
					exponent := c.code - 48
					needs_digit := False
				else
					last_state := 9
				end
			when 7 then
				if c.is_digit then
					exponent := exponent * 10 + c.code - 48
				elseif trailing_separators_acceptable and then trailing_separators.has (c) then
					last_state := 8
				else
					last_state := 9
				end
			when 8 then
				if not trailing_separators.has (c) then
					last_state := 9
				end
			else
			end
		end
	
feature {NONE} -- Implementation

	natural_part: REAL_64

	fractional_part: REAL_64

	fractional_divider: REAL_64

	exponent: INTEGER_32

	is_negative: BOOLEAN

	has_negative_exponent: BOOLEAN

	has_fractional_part: BOOLEAN

	needs_digit: BOOLEAN
			-- Used to calculate real/double value
	
note
	copyright: "Copyright (c) 1984-2017, Eiffel Software and others"
	license: "Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"
	source: "[
		Eiffel Software
		5949 Hollister Ave., Goleta, CA 93117 USA
		Telephone 805-685-1006, Fax 805-685-6869
		Website http://www.eiffel.com
		Customer support http://support.eiffel.com
	]"

end -- class STRING_TO_REAL_CONVERTOR
