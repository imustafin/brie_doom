note
	description: "Implementation of TUPLE"
	library: "Free implementation of ELKS library"
	status: "See notice at end of class."
	legal: "See notice at end of class."
	date: "$Date: 2017-03-23 19:18:26 +0000 (Thu, 23 Mar 2017) $"
	revision: "$Revision: 100033 $"

class 
	TUPLE

inherit
	HASHABLE
		redefine
			is_equal
		end

	MISMATCH_CORRECTOR
		redefine
			correct_mismatch,
			is_equal
		end

	READABLE_INDEXABLE [detachable separate ANY]
		rename
			upper as count
		redefine
			is_equal
		end

create 
	default_create

feature -- Access

	item alias "[]" (index: INTEGER_32): detachable separate ANY assign put
			-- Entry of key `index`.
			-- Was declared in TUPLE as synonym of at.
		do
			inspect item_code (index)
			when Boolean_code then
				Result := boolean_item (index)
			when Character_8_code then
				Result := character_8_item (index)
			when Character_32_code then
				Result := character_32_item (index)
			when Real_64_code then
				Result := real_64_item (index)
			when Real_32_code then
				Result := real_32_item (index)
			when Pointer_code then
				Result := pointer_item (index)
			when Natural_8_code then
				Result := natural_8_item (index)
			when Natural_16_code then
				Result := natural_16_item (index)
			when Natural_32_code then
				Result := natural_32_item (index)
			when Natural_64_code then
				Result := natural_64_item (index)
			when Integer_8_code then
				Result := integer_8_item (index)
			when Integer_16_code then
				Result := integer_16_item (index)
			when Integer_32_code then
				Result := integer_32_item (index)
			when Integer_64_code then
				Result := integer_64_item (index)
			when Reference_code then
				Result := reference_item (index)
			end
		end

	at alias "@" (index: INTEGER_32): detachable separate ANY assign put
			-- Entry of key `index`.
			-- Was declared in TUPLE as synonym of item.
		do
			inspect item_code (index)
			when Boolean_code then
				Result := boolean_item (index)
			when Character_8_code then
				Result := character_8_item (index)
			when Character_32_code then
				Result := character_32_item (index)
			when Real_64_code then
				Result := real_64_item (index)
			when Real_32_code then
				Result := real_32_item (index)
			when Pointer_code then
				Result := pointer_item (index)
			when Natural_8_code then
				Result := natural_8_item (index)
			when Natural_16_code then
				Result := natural_16_item (index)
			when Natural_32_code then
				Result := natural_32_item (index)
			when Natural_64_code then
				Result := natural_64_item (index)
			when Integer_8_code then
				Result := integer_8_item (index)
			when Integer_16_code then
				Result := integer_16_item (index)
			when Integer_32_code then
				Result := integer_32_item (index)
			when Integer_64_code then
				Result := integer_64_item (index)
			when Reference_code then
				Result := reference_item (index)
			end
		end

	reference_item (index: INTEGER_32): detachable separate ANY
			-- Reference item at `index`.
		require
			valid_index: valid_index (index)
			is_reference: is_reference_item (index)
		external
			"built_in"
		end

	boolean_item (index: INTEGER_32): BOOLEAN
			-- Boolean item at `index`.
		require
			valid_index: valid_index (index)
			is_boolean: is_boolean_item (index)
		external
			"built_in"
		end

	character_8_item (index: INTEGER_32): CHARACTER_8
			-- Character item at `index`.
		require
			valid_index: valid_index (index)
			is_character_8: is_character_8_item (index)
		external
			"built_in"
		end

	character_item (index: INTEGER_32): CHARACTER_8
			-- Character item at `index`.
		require
			valid_index: valid_index (index)
			is_character_8: is_character_8_item (index)
		do
			Result := character_8_item (index)
		end

	character_32_item (index: INTEGER_32): CHARACTER_32
			-- Character item at `index`.
		require
			valid_index: valid_index (index)
			is_character_32: is_character_32_item (index)
		external
			"built_in"
		end

	wide_character_item (index: INTEGER_32): CHARACTER_32
			-- Character item at `index`.
		require
			valid_index: valid_index (index)
			is_character_32: is_character_32_item (index)
		do
			Result := character_32_item (index)
		end

	real_64_item (index: INTEGER_32): REAL_64
			-- Double item at `index`.
		require
			valid_index: valid_index (index)
			is_numeric: is_double_item (index)
		external
			"built_in"
		end

	double_item (index: INTEGER_32): REAL_64
			-- Double item at `index`.
		require
			valid_index: valid_index (index)
			is_numeric: is_double_item (index)
		do
			Result := real_64_item (index)
		end

	natural_8_item (index: INTEGER_32): NATURAL_8
			-- NATURAL_8 item at `index`.
		require
			valid_index: valid_index (index)
			is_integer: is_natural_8_item (index)
		external
			"built_in"
		end

	natural_16_item (index: INTEGER_32): NATURAL_16
			-- NATURAL_16 item at `index`.
		require
			valid_index: valid_index (index)
			is_integer: is_natural_16_item (index)
		external
			"built_in"
		end

	natural_32_item (index: INTEGER_32): NATURAL_32
			-- NATURAL_32 item at `index`.
		require
			valid_index: valid_index (index)
			is_integer: is_natural_32_item (index)
		external
			"built_in"
		end

	natural_64_item (index: INTEGER_32): NATURAL_64
			-- NATURAL_64 item at `index`.
		require
			valid_index: valid_index (index)
			is_integer: is_natural_64_item (index)
		external
			"built_in"
		end

	integer_8_item (index: INTEGER_32): INTEGER_8
			-- INTEGER_8 item at `index`.
		require
			valid_index: valid_index (index)
			is_integer: is_integer_8_item (index)
		external
			"built_in"
		end

	integer_16_item (index: INTEGER_32): INTEGER_16
			-- INTEGER_16 item at `index`.
		require
			valid_index: valid_index (index)
			is_integer: is_integer_16_item (index)
		external
			"built_in"
		end

	integer_32_item (index: INTEGER_32): INTEGER_32
			-- INTEGER_32 item at `index`.
		require
			valid_index: valid_index (index)
			is_integer: is_integer_32_item (index)
		external
			"built_in"
		end

	integer_item (index: INTEGER_32): INTEGER_32
			-- INTEGER_32 item at `index`.
		require
			valid_index: valid_index (index)
			is_integer: is_integer_32_item (index)
		do
			Result := integer_32_item (index)
		end

	integer_64_item (index: INTEGER_32): INTEGER_64
			-- INTEGER_64 item at `index`.
		require
			valid_index: valid_index (index)
			is_integer: is_integer_64_item (index)
		external
			"built_in"
		end

	pointer_item (index: INTEGER_32): POINTER
			-- Pointer item at `index`.
		require
			valid_index: valid_index (index)
			is_pointer: is_pointer_item (index)
		external
			"built_in"
		end

	real_32_item (index: INTEGER_32): REAL_32
			-- real item at `index`.
		require
			valid_index: valid_index (index)
			is_real_or_integer: is_real_item (index)
		external
			"built_in"
		end

	real_item (index: INTEGER_32): REAL_32
			-- real item at `index`.
		require
			valid_index: valid_index (index)
			is_real_or_integer: is_real_item (index)
		do
			Result := real_32_item (index)
		end
	
feature -- Comparison

	object_comparison: BOOLEAN
			-- Must search operations use equal rather than `=`
			-- for comparing references? (Default: no, use `=`.)
		external
			"built_in"
		end

	is_equal (other: like Current): BOOLEAN
			-- Is `other` attached to an object considered
			-- equal to current object?
		local
			i, nb: INTEGER_32
			l_object_compare: BOOLEAN
		do
			l_object_compare := object_comparison
			if l_object_compare = other.object_comparison then
				if l_object_compare then
					nb := count
					if nb = other.count then
						from
							Result := True
							i := 1
						until
							i > nb or not Result
						loop
							Result := item (i) ~ other.item (i)
							i := i + 1
						end
					end
				else
					Result := Precursor {HASHABLE} (other)
				end
			end
		end
	
feature -- Status setting

	compare_objects
			-- Ensure that future search operations will use equal
			-- rather than `=` for comparing references.
		do
			set_object_comparison (True)
		ensure
			object_comparison: object_comparison
		end

	compare_references
			-- Ensure that future search operations will use `=`
			-- rather than equal for comparing references.
		do
			set_object_comparison (False)
		ensure
			reference_comparison: not object_comparison
		end
	
feature -- Status report

	hash_code: INTEGER_32
			-- Hash code value
		local
			i, nb, l_hash: INTEGER_32
		do
			from
				i := 1
				nb := count
			until
				i > nb
			loop
				inspect item_code (i)
				when Boolean_code then
					l_hash := boolean_item (i).hash_code
				when Character_8_code then
					l_hash := character_8_item (i).hash_code
				when Character_32_code then
					l_hash := character_32_item (i).hash_code
				when Real_64_code then
					l_hash := real_64_item (i).hash_code
				when Real_32_code then
					l_hash := real_32_item (i).hash_code
				when Pointer_code then
					l_hash := pointer_item (i).hash_code
				when Natural_8_code then
					l_hash := natural_8_item (i).hash_code
				when Natural_16_code then
					l_hash := natural_16_item (i).hash_code
				when Natural_32_code then
					l_hash := natural_32_item (i).hash_code
				when Natural_64_code then
					l_hash := natural_64_item (i).hash_code
				when Integer_8_code then
					l_hash := integer_8_item (i).hash_code
				when Integer_16_code then
					l_hash := integer_16_item (i).hash_code
				when Integer_32_code then
					l_hash := integer_32_item (i).hash_code
				when Integer_64_code then
					l_hash := integer_64_item (i).hash_code
				when Reference_code then
					if attached {HASHABLE} reference_item (i) as l_key then
						l_hash := l_key.hash_code
					else
						l_hash := 0
					end
				end
				Result := Result + l_hash * Internal_primes.i_th (i)
				i := i + 1
			end
			Result := Result.hash_code
		end

	valid_index (k: INTEGER_32): BOOLEAN
			-- Is `k` a valid key?
		do
			Result := k >= 1 and then k <= count
		end

	valid_type_for_index (v: detachable separate ANY; index: INTEGER_32): BOOLEAN
			-- Is object `v` a valid target for element at position `index`?
		require
			valid_index: valid_index (index)
		local
			l_reflector: REFLECTOR
			l_type_id: INTEGER_32
		do
			if v = Void then
				if item_code (index) = Reference_code then
					Result := not generating_type.generic_parameter_type (index).is_attached
				end
			else
				inspect item_code (index)
				when Boolean_code then
					Result := attached {BOOLEAN_REF} v
				when Character_8_code then
					Result := attached {CHARACTER_8_REF} v
				when Character_32_code then
					Result := attached {CHARACTER_32_REF} v
				when Real_64_code then
					Result := attached {REAL_64_REF} v
				when Real_32_code then
					Result := attached {REAL_32_REF} v
				when Pointer_code then
					Result := attached {POINTER_REF} v
				when Natural_8_code then
					Result := attached {NATURAL_8_REF} v
				when Natural_16_code then
					Result := attached {NATURAL_16_REF} v
				when Natural_32_code then
					Result := attached {NATURAL_32_REF} v
				when Natural_64_code then
					Result := attached {NATURAL_64_REF} v
				when Integer_8_code then
					Result := attached {INTEGER_8_REF} v
				when Integer_16_code then
					Result := attached {INTEGER_16_REF} v
				when Integer_32_code then
					Result := attached {INTEGER_32_REF} v
				when Integer_64_code then
					Result := attached {INTEGER_64_REF} v
				when Reference_code then
					create l_reflector
					l_type_id := {ISE_RUNTIME}.dynamic_type (v)
					Result := l_reflector.field_conforms_to (l_type_id, generating_type.generic_parameter_type (index).type_id)
				end
			end
		end

	count: INTEGER_32
			-- Number of element in Current.
		external
			"built_in"
		end

	Lower: INTEGER_32 = 1
			-- Lower bound of TUPLE.

	upper: INTEGER_32
			-- Upper bound of TUPLE.
			-- Use count instead.
		do
			Result := count
		ensure
			definition: Result = count
		end

	is_empty: BOOLEAN
			-- Is Current empty?
		do
			Result := count = 0
		end
	
feature -- Element change

	put (v: detachable separate ANY; index: INTEGER_32)
			-- Insert `v` at position `index`.
		require
			valid_index: valid_index (index)
			valid_type_for_index: valid_type_for_index (v, index)
		do
			inspect item_code (index)
			when Boolean_code then
				if attached {BOOLEAN_REF} v as l_b then
					put_boolean (l_b.item, index)
				end
			when Character_8_code then
				if attached {CHARACTER_8_REF} v as l_c then
					put_character_8 (l_c.item, index)
				end
			when Character_32_code then
				if attached {CHARACTER_32_REF} v as l_wc then
					put_character_32 (l_wc.item, index)
				end
			when Real_64_code then
				if attached {REAL_64_REF} v as l_d then
					put_real_64 (l_d.item, index)
				end
			when Real_32_code then
				if attached {REAL_32_REF} v as l_r then
					put_real_32 (l_r.item, index)
				end
			when Pointer_code then
				if attached {POINTER_REF} v as l_p then
					put_pointer (l_p.item, index)
				end
			when Natural_8_code then
				if attached {NATURAL_8_REF} v as l_ui8 then
					put_natural_8 (l_ui8.item, index)
				end
			when Natural_16_code then
				if attached {NATURAL_16_REF} v as l_ui16 then
					put_natural_16 (l_ui16.item, index)
				end
			when Natural_32_code then
				if attached {NATURAL_32_REF} v as l_ui32 then
					put_natural_32 (l_ui32.item, index)
				end
			when Natural_64_code then
				if attached {NATURAL_64_REF} v as l_ui64 then
					put_natural_64 (l_ui64.item, index)
				end
			when Integer_8_code then
				if attached {INTEGER_8_REF} v as l_i8 then
					put_integer_8 (l_i8.item, index)
				end
			when Integer_16_code then
				if attached {INTEGER_16_REF} v as l_i16 then
					put_integer_16 (l_i16.item, index)
				end
			when Integer_32_code then
				if attached {INTEGER_32_REF} v as l_i32 then
					put_integer_32 (l_i32.item, index)
				end
			when Integer_64_code then
				if attached {INTEGER_64_REF} v as l_i64 then
					put_integer_64 (l_i64.item, index)
				end
			when Reference_code then
				put_reference (v, index)
			end
		end

	put_reference (v: detachable separate ANY; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type_for_index: valid_type_for_index (v, index)
			valid_type: is_reference_item (index)
		external
			"built_in"
		end

	put_boolean (v: BOOLEAN; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_boolean_item (index)
		external
			"built_in"
		end

	put_character_8 (v: CHARACTER_8; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_character_8_item (index)
		external
			"built_in"
		end

	put_character (v: CHARACTER_8; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_character_8_item (index)
		do
			put_character_8 (v, index)
		end

	put_character_32 (v: CHARACTER_32; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_character_32_item (index)
		external
			"built_in"
		end

	put_wide_character (v: CHARACTER_32; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_character_32_item (index)
		do
			put_character_32 (v, index)
		end

	put_real_64 (v: REAL_64; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_double_item (index)
		external
			"built_in"
		end

	put_double (v: REAL_64; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_double_item (index)
		do
			put_real_64 (v, index)
		end

	put_real_32 (v: REAL_32; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_real_item (index)
		external
			"built_in"
		end

	put_real (v: REAL_32; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_real_item (index)
		do
			put_real_32 (v, index)
		end

	put_pointer (v: POINTER; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_pointer_item (index)
		external
			"built_in"
		end

	put_natural_8 (v: NATURAL_8; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_natural_8_item (index)
		external
			"built_in"
		end

	put_natural_16 (v: NATURAL_16; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_natural_16_item (index)
		external
			"built_in"
		end

	put_natural_32 (v: NATURAL_32; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_natural_32_item (index)
		external
			"built_in"
		end

	put_natural_64 (v: NATURAL_64; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_natural_64_item (index)
		external
			"built_in"
		end

	put_integer_32 (v: INTEGER_32; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_integer_32_item (index)
		external
			"built_in"
		end

	put_integer (v: INTEGER_32; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_integer_32_item (index)
		do
			put_integer_32 (v, index)
		end

	put_integer_8 (v: INTEGER_8; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_integer_8_item (index)
		external
			"built_in"
		end

	put_integer_16 (v: INTEGER_16; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_integer_16_item (index)
		external
			"built_in"
		end

	put_integer_64 (v: INTEGER_64; index: INTEGER_32)
			-- Put `v` at position `index` in Current.
		require
			valid_index: valid_index (index)
			valid_type: is_integer_64_item (index)
		external
			"built_in"
		end
	
feature -- Type queries

	is_boolean_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` a BOOLEAN?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Boolean_code
		end

	is_character_8_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` a CHARACTER_8?
			-- Was declared in TUPLE as synonym of is_character_item.
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Character_8_code
		end

	is_character_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` a CHARACTER_8?
			-- Was declared in TUPLE as synonym of is_character_8_item.
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Character_8_code
		end

	is_character_32_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` a CHARACTER_32?
			-- Was declared in TUPLE as synonym of is_wide_character_item.
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Character_32_code
		end

	is_wide_character_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` a CHARACTER_32?
			-- Was declared in TUPLE as synonym of is_character_32_item.
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Character_32_code
		end

	is_double_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` a REAL_64?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Real_64_code
		end

	is_natural_8_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` an NATURAL_8?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Natural_8_code
		end

	is_natural_16_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` an NATURAL_16?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Natural_16_code
		end

	is_natural_32_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` an NATURAL_32?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Natural_32_code
		end

	is_natural_64_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` an NATURAL_64?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Natural_64_code
		end

	is_integer_8_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` an INTEGER_8?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Integer_8_code
		end

	is_integer_16_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` an INTEGER_16?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Integer_16_code
		end

	is_integer_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` an INTEGER_32?
			-- Was declared in TUPLE as synonym of is_integer_32_item.
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Integer_32_code
		end

	is_integer_32_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` an INTEGER_32?
			-- Was declared in TUPLE as synonym of is_integer_item.
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Integer_32_code
		end

	is_integer_64_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` an INTEGER_64?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Integer_64_code
		end

	is_pointer_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` a POINTER?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Pointer_code
		end

	is_real_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` a REAL_32?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Real_32_code
		end

	is_reference_item (index: INTEGER_32): BOOLEAN
			-- Is item at `index` a REFERENCE?
		require
			valid_index: valid_index (index)
		do
			Result := item_code (index) = Reference_code
		end

	is_numeric_item (index: INTEGER_32): BOOLEAN
		obsolete "Use the precise type query instead. [2017-05-31]"
			-- Is item at `index` a number?
		require
			valid_index: valid_index (index)
		local
			tcode: like item_code
		do
			tcode := item_code (index)
			inspect tcode
			when Integer_8_code, Integer_16_code, Integer_32_code, Integer_64_code, Real_32_code, Real_64_code then
				Result := True
			else
			end
		end

	is_uniform: BOOLEAN
			-- Are all items of the same basic type or all of reference type?
		do
			Result := is_tuple_uniform (Any_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_boolean: BOOLEAN
			-- Are all items of type BOOLEAN?
		do
			Result := is_tuple_uniform (Boolean_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_character_8: BOOLEAN
			-- Are all items of type CHARACTER_8?
			-- Was declared in TUPLE as synonym of is_uniform_character.
		do
			Result := is_tuple_uniform (Character_8_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_character: BOOLEAN
			-- Are all items of type CHARACTER_8?
			-- Was declared in TUPLE as synonym of is_uniform_character_8.
		do
			Result := is_tuple_uniform (Character_8_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_character_32: BOOLEAN
			-- Are all items of type CHARACTER_32?
			-- Was declared in TUPLE as synonym of is_uniform_wide_character.
		do
			Result := is_tuple_uniform (Character_32_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_wide_character: BOOLEAN
			-- Are all items of type CHARACTER_32?
			-- Was declared in TUPLE as synonym of is_uniform_character_32.
		do
			Result := is_tuple_uniform (Character_32_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_double: BOOLEAN
			-- Are all items of type REAL_64?
		do
			Result := is_tuple_uniform (Real_64_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_natural_8: BOOLEAN
			-- Are all items of type NATURAL_8?
		do
			Result := is_tuple_uniform (Natural_8_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_natural_16: BOOLEAN
			-- Are all items of type NATURAL_16?
		do
			Result := is_tuple_uniform (Natural_16_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_natural_32: BOOLEAN
			-- Are all items of type NATURAL_32?
		do
			Result := is_tuple_uniform (Natural_32_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_natural_64: BOOLEAN
			-- Are all items of type NATURAL_64?
		do
			Result := is_tuple_uniform (Natural_64_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_integer_8: BOOLEAN
			-- Are all items of type INTEGER_8?
		do
			Result := is_tuple_uniform (Integer_8_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_integer_16: BOOLEAN
			-- Are all items of type INTEGER_16?
		do
			Result := is_tuple_uniform (Integer_16_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_integer: BOOLEAN
			-- Are all items of type INTEGER?
			-- Was declared in TUPLE as synonym of is_uniform_integer_32.
		do
			Result := is_tuple_uniform (Integer_32_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_integer_32: BOOLEAN
			-- Are all items of type INTEGER?
			-- Was declared in TUPLE as synonym of is_uniform_integer.
		do
			Result := is_tuple_uniform (Integer_32_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_integer_64: BOOLEAN
			-- Are all items of type INTEGER_64?
		do
			Result := is_tuple_uniform (Integer_64_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_pointer: BOOLEAN
			-- Are all items of type POINTER?
		do
			Result := is_tuple_uniform (Pointer_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_real: BOOLEAN
			-- Are all items of type REAL_32?
		do
			Result := is_tuple_uniform (Real_32_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	is_uniform_reference: BOOLEAN
			-- Are all items of reference type?
		do
			Result := is_tuple_uniform (Reference_code)
		ensure
			yes_if_empty: (count = 0) implies Result
		end
	
feature -- Concatenation

	plus alias "+" (a_other: TUPLE): detachable like Current
			-- Concatenation of `Current` with `a_other`.
		local
			l_reflector: REFLECTOR
			i, n1, n2: INTEGER_32
			t1, t2: TYPE [detachable TUPLE]
			l_type_id: INTEGER_32
			l_items: SPECIAL [detachable separate ANY]
			l_type_string: STRING_8
		do
			n1 := count
			n2 := a_other.count
			if n1 = 0 then
				if attached {like plus} a_other.twin as l_res then
					Result := l_res
				else
					check
						current_is_empty_tuple: count = 0
					end
				end
			elseif n2 = 0 then
				Result := twin
			else
				create l_type_string.make_from_string ("TUPLE [")
				create l_items.make_empty (n1 + n2)
				from
					t1 := generating_type
					check
						same_count: t1.generic_parameter_count = n1
					end
					i := 1
				until
					i > n1
				loop
					if i > 1 then
						l_type_string.append_character (',')
						l_type_string.append_character (' ')
					end
					l_type_string.append (t1.generic_parameter_type (i).name)
					l_items.force (item (i), i - 1)
					i := i + 1
				end
				from
					t2 := a_other.generating_type
					check
						same_count: t2.generic_parameter_count = n2
					end
				until
					i > n1 + n2
				loop
					l_type_string.append_character (',')
					l_type_string.append_character (' ')
					l_type_string.append (t2.generic_parameter_type (i - n1).name)
					l_items.force (a_other.item (i - n1), i - 1)
					i := i + 1
				end
				l_type_string.append_character (']')
				create l_reflector
				l_type_id := l_reflector.dynamic_type_from_string (l_type_string)
				if l_type_id >= 0 then
					if attached {like plus} l_reflector.new_tuple_from_special (l_type_id, l_items) as res then
						Result := res
					end
				end
			end
		ensure
			has_expected_count: Result /= Void implies Result.count = count + a_other.count
			has_expected_items: Result /= Void implies ((across
					1 |..| count as ic_1
				all
					Result [ic_1.item] = item (ic_1.item)
				end) and (across
					1 |..| a_other.count as ic_2
				all
					Result [count + ic_2.item] = a_other [ic_2.item]
				end))
		end
	
feature -- Type conversion queries

	convertible_to_double: BOOLEAN
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Is current convertible to an array of doubles?
		local
			i, cnt: INTEGER_32
			tcode: like item_code
		do
			Result := True
			from
				i := 1
				cnt := count
			until
				i > cnt or else not Result
			loop
				tcode := item_code (i)
				inspect tcode
				when Integer_8_code, Integer_16_code, Integer_32_code, Integer_64_code, Real_32_code, Real_64_code then
					Result := True
				else
					Result := False
				end
				i := i + 1
			end
		ensure
			yes_if_empty: (count = 0) implies Result
		end

	convertible_to_real: BOOLEAN
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Is current convertible to an array of reals?
		local
			i, cnt: INTEGER_32
			tcode: like item_code
		do
			Result := True
			from
				i := 1
				cnt := count
			until
				i > cnt or else not Result
			loop
				tcode := item_code (i)
				inspect tcode
				when Integer_8_code, Integer_16_code, Integer_32_code, Integer_64_code, Real_32_code then
					Result := True
				else
					Result := False
				end
				i := i + 1
			end
		ensure
			yes_if_empty: (count = 0) implies Result
		end
	
feature -- Conversion

	arrayed: ARRAY [detachable separate ANY]
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Items of Current as array
		local
			i, cnt: INTEGER_32
		do
			from
				i := 1
				cnt := count
				create Result.make_filled (Void, 1, cnt)
			until
				i > cnt
			loop
				Result.put (item (i), i)
				i := i + 1
			end
		ensure
			exists: Result /= Void
			same_count: Result.count = count
			same_items: 
		end

	boolean_arrayed: ARRAY [BOOLEAN]
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Items of Current as array
		require
			is_uniform_boolean: is_uniform_boolean
		local
			i, cnt: INTEGER_32
		do
			from
				i := 1
				cnt := count
				create Result.make_filled (False, 1, cnt)
			until
				i > cnt
			loop
				Result.put (boolean_item (i), i)
				i := i + 1
			end
		ensure
			exists: Result /= Void
			same_count: Result.count = count
			same_items: 
		end

	character_8_arrayed: ARRAY [CHARACTER_8]
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Items of Current as array
			-- Was declared in TUPLE as synonym of character_arrayed.
		require
			is_uniform_character: is_uniform_character
		local
			i, cnt: INTEGER_32
		do
			from
				i := 1
				cnt := count
				create Result.make_filled (' ', 1, cnt)
			until
				i > cnt
			loop
				Result.put (character_8_item (i), i)
				i := i + 1
			end
		ensure
			exists: Result /= Void
			same_count: Result.count = count
			same_items: 
		end

	character_arrayed: ARRAY [CHARACTER_8]
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Items of Current as array
			-- Was declared in TUPLE as synonym of character_8_arrayed.
		require
			is_uniform_character: is_uniform_character
		local
			i, cnt: INTEGER_32
		do
			from
				i := 1
				cnt := count
				create Result.make_filled (' ', 1, cnt)
			until
				i > cnt
			loop
				Result.put (character_8_item (i), i)
				i := i + 1
			end
		ensure
			exists: Result /= Void
			same_count: Result.count = count
			same_items: 
		end

	double_arrayed: ARRAY [REAL_64]
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Items of Current as array
		require
			convertible: convertible_to_double
		local
			i, cnt: INTEGER_32
		do
			from
				i := 1
				cnt := count
				create Result.make_filled ({REAL_64} 0.0, 1, cnt)
			until
				i > cnt
			loop
				Result.put (double_item (i), i)
				i := i + 1
			end
		ensure
			exists: Result /= Void
			same_count: Result.count = count
			same_items: 
		end

	integer_arrayed: ARRAY [INTEGER_32]
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Items of Current as array
		require
			is_uniform_integer: is_uniform_integer
		local
			i, cnt: INTEGER_32
		do
			from
				i := 1
				cnt := count
				create Result.make_filled ({INTEGER_32} 0, 1, cnt)
			until
				i > cnt
			loop
				Result.put (integer_32_item (i), i)
				i := i + 1
			end
		ensure
			exists: Result /= Void
			same_count: Result.count = count
			same_items: 
		end

	pointer_arrayed: ARRAY [POINTER]
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Items of Current as array
		require
			is_uniform_pointer: is_uniform_pointer
		local
			i, cnt: INTEGER_32
		do
			from
				i := 1
				cnt := count
				create Result.make_filled (default_pointer, 1, cnt)
			until
				i > cnt
			loop
				Result.put (pointer_item (i), i)
				i := i + 1
			end
		ensure
			exists: Result /= Void
			same_count: Result.count = count
			same_items: 
		end

	real_arrayed: ARRAY [REAL_32]
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Items of Current as array
		require
			convertible: convertible_to_real
		local
			i, cnt: INTEGER_32
		do
			from
				i := 1
				cnt := count
				create Result.make_filled ({REAL_32} 0.0, 1, cnt)
			until
				i > cnt
			loop
				Result.put (real_item (i), i)
				i := i + 1
			end
		ensure
			exists: Result /= Void
			same_count: Result.count = count
			same_items: 
		end

	string_arrayed: ARRAY [detachable STRING_8]
		obsolete "Will be removed in future releases. [2017-05-31]"
			-- Items of Current as array
			-- NOTE: Items with a type not cconforming to
			--       type STRING are set to Void.
		local
			i, cnt: INTEGER_32
		do
			from
				i := 1
				cnt := count
				create Result.make_filled (Void, 1, cnt)
			until
				i > cnt
			loop
				if attached {STRING_8} item (i) as s then
					Result.put (s, i)
				end
				i := i + 1
			end
		ensure
			exists: Result /= Void
			same_count: Result.count = count
		end
	
feature -- Retrieval

	correct_mismatch
			-- Attempt to correct object mismatch using Mismatch_information.
		local
			i, nb: INTEGER_32
			l_any: ANY
		do
			if attached {SPECIAL [ANY]} Mismatch_information.item (Area_name) as l_area then
				from
					i := 1
					nb := l_area.count
				until
					i > nb
				loop
					l_any := l_area.item (i - 1)
					if valid_type_for_index (l_any, i) then
						put (l_any, i)
					else
						Precursor {MISMATCH_CORRECTOR}
					end
					i := i + 1
				end
			else
				Precursor {MISMATCH_CORRECTOR}
			end
		end
	
feature -- Access: lower level

	item_code (index: INTEGER_32): NATURAL_8
			-- Type code of item at `index`. Used for
			-- argument processing in ROUTINE
		require
			valid_index: valid_index (index)
		external
			"built_in"
		end

	Reference_code: NATURAL_8 = 0

	Boolean_code: NATURAL_8 = 1

	Character_8_code: NATURAL_8 = 2
			-- Was declared in TUPLE as synonym of Character_code.

	Character_code: NATURAL_8 = 2
			-- Was declared in TUPLE as synonym of Character_8_code.

	Real_64_code: NATURAL_8 = 3

	Real_32_code: NATURAL_8 = 4

	Pointer_code: NATURAL_8 = 5

	Integer_8_code: NATURAL_8 = 6

	Integer_16_code: NATURAL_8 = 7

	Integer_32_code: NATURAL_8 = 8

	Integer_64_code: NATURAL_8 = 9

	Natural_8_code: NATURAL_8 = 10

	Natural_16_code: NATURAL_8 = 11

	Natural_32_code: NATURAL_8 = 12

	Natural_64_code: NATURAL_8 = 13

	Character_32_code: NATURAL_8 = 14
			-- Was declared in TUPLE as synonym of Wide_character_code.

	Wide_character_code: NATURAL_8 = 14
			-- Was declared in TUPLE as synonym of Character_32_code.

	Any_code: NATURAL_8 = 255
			-- Code used to identify type in TUPLE.
	
feature {NONE} -- Implementation

	Area_name: STRING_8 = "area"
			-- Name of attributes where TUPLE elements were stored.

	is_tuple_uniform (code: like item_code): BOOLEAN
			-- Are all items of type `code`?
		local
			i, nb: INTEGER_32
			l_code: like item_code
		do
			Result := True
			if count > 0 then
				from
					nb := count
					if code = Any_code then
						i := 2
						l_code := item_code (1)
					else
						i := 1
						l_code := code
					end
				until
					i > nb or not Result
				loop
					Result := l_code = item_code (i)
					i := i + 1
				end
			end
		end

	Internal_primes: PRIMES
			-- For quick access to prime numbers.
		once
			create Result
		end

	set_object_comparison (b: BOOLEAN)
			-- Set object_comparison to `b`.
		external
			"built_in"
		ensure
			object_comparison_set: object_comparison = b
		end
	
note
	copyright: "Copyright (c) 1984-2017, Eiffel Software and others"
	license: "Eiffel Forum License v2 (see http://www.eiffel.com/licensing/forum.txt)"
	source: "[
		Eiffel Software
		5949 Hollister Ave., Goleta, CA 93117 USA
		Telephone 805-685-1006, Fax 805-685-6869
		Website http://www.eiffel.com
		Customer support http://support.eiffel.com
	]"

end -- class TUPLE
